import jsPDF from 'jspdf';
import { AnalysisResult } from './codeAnalyzer';

export interface PDFReportData {
  fileName: string;
  analysisResult: AnalysisResult;
  userEmail: string;
  timestamp: Date;
}

export class PDFReportGenerator {
  public generateReport(data: PDFReportData): Blob {
    const doc = new jsPDF();
    const { fileName, analysisResult, userEmail, timestamp } = data;
    
    // Header
    doc.setFontSize(20);
    doc.text('Code Quality Analysis Report', 20, 30);
    
    // Metadata
    doc.setFontSize(12);
    doc.text(`File: ${fileName}`, 20, 50);
    doc.text(`Analyzed by: ${userEmail}`, 20, 60);
    doc.text(`Date: ${timestamp.toLocaleDateString()} ${timestamp.toLocaleTimeString()}`, 20, 70);
    
    // Overall Score
    doc.setFontSize(16);
    doc.text('Overall Score', 20, 90);
    doc.setFontSize(24);
    const [r, g, b] = this.getScoreColor(analysisResult.overallScore);
    doc.setTextColor(r, g, b);
    doc.text(`${analysisResult.overallScore}/100`, 20, 105);
    doc.setTextColor(0, 0, 0); // Reset to black
    
    // Score Description
    doc.setFontSize(12);
    const scoreDescription = this.getScoreDescription(analysisResult.overallScore);
    doc.text(scoreDescription, 20, 115);
    
    // Category Breakdown
    doc.setFontSize(14);
    doc.text('Category Breakdown', 20, 135);
    
    let yPosition = 145;
    analysisResult.categories.forEach((category, index) => {
      doc.setFontSize(11);
      doc.text(`${category.name}:`, 20, yPosition);
      doc.text(`${category.score}/${category.maxScore}`, 150, yPosition);
      
      // Progress bar visual
      const barWidth = 50;
      const barHeight = 3;
      const fillWidth = (category.score / category.maxScore) * barWidth;
      
      // Background bar
      doc.setFillColor(220, 220, 220);
      doc.rect(20, yPosition + 3, barWidth, barHeight, 'F');
      
      // Fill bar
      const [r, g, b] = this.getCategoryColor(category.score / category.maxScore);
      doc.setFillColor(r, g, b);
      doc.rect(20, yPosition + 3, fillWidth, barHeight, 'F');
      
      yPosition += 15;
      
      // Add new page if needed
      if (yPosition > 260 && index < analysisResult.categories.length - 1) {
        doc.addPage();
        yPosition = 30;
      }
    });
    
    // Keywords Matched
    if (yPosition > 200) {
      doc.addPage();
      yPosition = 30;
    }
    
    doc.setFontSize(14);
    doc.text('Keywords Matched', 20, yPosition);
    yPosition += 15;
    
    doc.setFontSize(10);
    const keywordsText = analysisResult.keywordsMatched.join(', ') || 'None';
    const keywordsLines = doc.splitTextToSize(keywordsText, 170);
    doc.text(keywordsLines, 20, yPosition);
    yPosition += keywordsLines.length * 5 + 10;
    
    // Scores Breakdown
    doc.setFontSize(14);
    doc.text('Detailed Scores', 20, yPosition);
    yPosition += 15;
    
    doc.setFontSize(11);
    doc.text(`Functionality Score: ${analysisResult.functionalityScore}/100`, 20, yPosition);
    yPosition += 10;
    doc.text(`Similarity Score: ${analysisResult.similarityScore}/100`, 20, yPosition);
    yPosition += 15;
    
    // Recommendations
    if (analysisResult.recommendations.length > 0) {
      doc.setFontSize(14);
      doc.text('Recommendations', 20, yPosition);
      yPosition += 15;
      
      doc.setFontSize(10);
      analysisResult.recommendations.forEach((recommendation, index) => {
        const recText = `${index + 1}. ${recommendation}`;
        const recLines = doc.splitTextToSize(recText, 170);
        doc.text(recLines, 20, yPosition);
        yPosition += recLines.length * 5 + 5;
        
        // Add new page if needed
        if (yPosition > 260 && index < analysisResult.recommendations.length - 1) {
          doc.addPage();
          yPosition = 30;
        }
      });
    }
    
    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(`Page ${i} of ${pageCount} - Generated by CodeScore`, 20, 285);
      doc.text(`Report ID: ${this.generateReportId()}`, 150, 285);
    }
    
    return doc.output('blob');
  }
  
  private getScoreColor(score: number): [number, number, number] {
    if (score >= 80) return [34, 197, 94]; // Green
    if (score >= 60) return [251, 191, 36]; // Yellow
    if (score >= 40) return [249, 115, 22]; // Orange
    return [239, 68, 68]; // Red
  }
  
  private getCategoryColor(ratio: number): [number, number, number] {
    if (ratio >= 0.8) return [34, 197, 94]; // Green
    if (ratio >= 0.6) return [251, 191, 36]; // Yellow
    if (ratio >= 0.4) return [249, 115, 22]; // Orange
    return [239, 68, 68]; // Red
  }
  
  private getScoreDescription(score: number): string {
    if (score >= 90) return "Excellent - Your code demonstrates exceptional quality and best practices.";
    if (score >= 80) return "Good - Your code shows solid quality with minor areas for improvement.";
    if (score >= 70) return "Fair - Your code is functional but has several areas that could be enhanced.";
    if (score >= 60) return "Below Average - Your code needs significant improvements in multiple areas.";
    return "Poor - Your code requires major refactoring and attention to best practices.";
  }
  
  private generateReportId(): string {
    return Math.random().toString(36).substr(2, 9).toUpperCase();
  }
}